# CLUSTERING ==========================================================================================================

# Documentation at http://clusteringjl.readthedocs.org/en/latest/.

using Clustering

# CHOOSE DATA ---------------------------------------------------------------------------------------------------------

using RDatasets

# Check out some of the available clustering data sets.
#
RDatasets.datasets("cluster")

# -> Bivariate Data Set with 3 Clusters
#
xclara = dataset("cluster", "xclara")
#
# Rename columns.
#
names!(xclara, [symbol(i) for i in ["x", "y"]])

using Gadfly

# Visually identify three clusters.
#
plot(x = xclara[:x], y = xclara[:y], Geom.point())

# -> Isotopic Composition Plutonium Batches
#
pluton = dataset("cluster", "pluton")

# DATA PREPARATION ----------------------------------------------------------------------------------------------------

# Convert to an Array
#
xclara = convert(Array, xclara);

# Transpose (Clustering expects each sample to be in a separate column).
#
xclara = xclara';

# And do the same for our Plutonium data.
#
pluton = convert(Array, pluton);
pluton = pluton';

# DISTANCE MATRIX -----------------------------------------------------------------------------------------------------

using Distances

dclara = pairwise(Euclidean(), xclara);
dclara[1:5, 1:5]

# INITIALISATION ------------------------------------------------------------------------------------------------------

initseeds(:rand, xclara, 3)			# Random selection
seeds = initseeds(:kmpp, xclara, 3)		# Kmeans++ algorithm
initseeds(:kmcen, xclara, 3)			# Select samples with highest centrality

initseeds_by_costs(:rand, dclara.^2, 3)
initseeds_by_costs(:kmpp, dclara.^2, 3)
initseeds_by_costs(:kmcen, dclara.^2, 3)

# K-MEANS -------------------------------------------------------------------------------------------------------------

# Perform k-means clustering, returning an object of type KmeansResult.
#
xclara_kmeans = kmeans(xclara, 3)

# Cluster centers
#
xclara_kmeans.centers

# Cluster assignments and counts.
#
xclara_kmeans.assignments
assignments(xclara_kmeans)
#
xclara_kmeans.counts
counts(xclara_kmeans)

# Check that we got the specified number of clusters.
#
@assert nclusters(xclara_kmeans) == 3

# Perform k-means clustering using initial seeds. You can either specity the method or a vector of seeds generated by
# one of the initialisation methods above.
#
# Options for display are :none, :iter and :final.
#
xclara_kmeans = kmeans(xclara, 3, init = :kmpp, display = :iter)

# K-MEDIODS -----------------------------------------------------------------------------------------------------------

# Perform k-mediods clustering, returning an object of type KmedoidsResult.
#
xclara_kmedoids = kmedoids(dclara, 3)

# Cluster centers
#
xclara_kmedoids.medoids

# Cluster assignments and counts.
#
xclara_kmedoids.assignments
assignments(xclara_kmedoids)
#
xclara_kmedoids.counts
counts(xclara_kmedoids)

# Plot points coloured with cluster assignment.
#
plot(x = xclara[1,:], y = xclara[2,:], color = assignments(xclara_kmedoids), Geom.point())

# Perform k-mediods clustering using initial seeds.
#
xclara_kmedoids = kmedoids(dclara, 3, init = seeds, display = :final)

# DBSCAN --------------------------------------------------------------------------------------------------------------

# DBSCAN is a density based clustering algorithm.

# Perform DBSCAN clustering, returning an object of type DbscanResult.
#
xclara_dbscan = dbscan(dclara, 5, 10)

plot(x = xclara[1,:], y = xclara[2,:], color = assignments(xclara_dbscan), Geom.point())

# AFFINITY PROPAGATION ------------------------------------------------------------------------------------------------

# affinityprop() performs affinity propagation, returning an object of type AffinityPropResult.


